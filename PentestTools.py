import importlib
import os
import sys
import argparse
from PentestTools.result import output_console, output_table, output_csv, output_json, output_xml


class PentestTools:
    def __init__(self):
        self.modules = self.discover_modules()

    def discover_modules(self):
        base_dir = os.path.dirname(os.path.abspath(__file__))
        modules_dir = os.path.join(base_dir, 'PentestTools', 'modules')
        modules = [f.replace('.py', '') for f in os.listdir(modules_dir) if f.endswith('.py') and f != '__init__.py']
        #print(f"Discovered modules: {modules}")  # Debug: list discovered modules
        return modules

    def load_module(self, module_name):
        if module_name not in self.modules:
            print(f"Error: Module '{module_name}' is not in the list of discovered modules.")
            return None

        try:
            module = importlib.import_module(f'PentestTools.modules.{module_name}')
            #print(f"Module '{module_name}' successfully imported.")  # Debug: Successful import
            if hasattr(module, 'run'):
                return module
            else:
                print(f"Error: Module '{module_name}' does not have a 'run' function.")
                return None
        except ImportError as e:
            print(f"ImportError: {e}")  # Debug: Output error if import fails
            return None
        except Exception as e:
            print(f"Unexpected error while loading module '{module_name}': {e}")  # Debug: Catch any unexpected errors
            return None

    def list_modules(self):
        print("Available modules:")
        for module in self.modules:
            print(f" - {module}")

    def run_module(self, module_name, args):
        module = self.load_module(module_name)
        if module and callable(getattr(module, 'run', None)):
            try:
                results = module.run(args)
                return results
            except Exception as e:
                print(f"Error running module '{module_name}': {e}")
                return None
        else:
            print(f"Error: Module '{module_name}' does not have a 'run' function or could not be loaded.")
            return None

    def run_all_modules(self, args, output_formats):
        all_results = []
        for module_name in self.modules:
            if module_name != "sample_module":
                results = self.run_module(module_name, args)
                if results:
                    all_results.extend(results)
        self.output_results(all_results, output_formats)


    def output_results(self, results, formats):
        for format in formats:
            if format == 'console':
                output_console(results)
            elif format == 'csv':
                output_csv(results)
            elif format == 'json':
                output_json(results)
            elif format == 'xml':
                output_xml(results)
            elif format == 'table':
                output_table(results)


def main():
    #print(f"Pentest Tools v0.1")
    #print("")
    parser = argparse.ArgumentParser(description='Pentest Tools')    
    parser.add_argument('module', nargs='?', help='The module to run')
    parser.add_argument('module_options', nargs=argparse.REMAINDER, help='Options for the module')
    parser.add_argument('--output', choices=['console', 'table', 'csv', 'json', 'xml'], default=['table'],
                        nargs='+', help='Specify output format(s)')

    args = parser.parse_args()

    framework = PentestTools()
    
    if not args.module:
        framework.list_modules()
        return
    
    if args.module == 'all':
        #print("Running all modules...")
        framework.run_all_modules(args.module_options, args.output)
    elif args.module and args.module in framework.modules:
        results = framework.run_module(args.module, args.module_options)
        if results:
            framework.output_results(results, args.output)        
    else:
        print(f"Error: Module '{args.module}' is not available.")
            


if __name__ == '__main__':
    main()
